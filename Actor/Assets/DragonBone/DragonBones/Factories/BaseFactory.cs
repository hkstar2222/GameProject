// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using Com.Viperstudio.Utils;
namespace DragonBones
{
	
	public class BaseFactory
	{

		protected enum AutoSearchType {AST_ALL, AST_AUTO, AST_NONE};
		
	    public bool autoSearchDragonBonesData;
		public	bool autoSearchTexture;
		
	    protected string _currentDragonBonesDataName;
		protected string _currentTextureAtlasName;
		protected Dictionary<string, DragonBonesData> _dragonBonesDataMap = new Dictionary<string, DragonBonesData>();
		protected Dictionary<string, ITextureAtlas> _textureAtlasMap = new Dictionary<string, ITextureAtlas>();

		public Dictionary<string, DragonBonesData> getDragonBonesDataMap()
		{
			return _dragonBonesDataMap;
		}

		public Dictionary<string, ITextureAtlas> getTextureAtlasMap()
		{
			return _textureAtlasMap;
		}


		public BaseFactory ()
		{
		

		}

	public DragonBonesData getDragonBonesData(string name) 
	{

		if (_dragonBonesDataMap.ContainsKey(name))
		{
			return _dragonBonesDataMap[name];
		}
		
		return null;
		
	}
	
	public void addDragonBonesData(DragonBonesData data, string name)
	{
		//DBASSERT(data, "Invalid data.");
		
		string key = name.Length<=0 ? data.name : name;
		
		//DBASSERT(!key.empty(), "Name is empty.");
		
		//DBASSERT(_dragonBonesDataMap.find(key) == _dragonBonesDataMap.end(), "Data has been added.");
		
		_dragonBonesDataMap[key] = data;
	}
	
	public void removeDragonBonesData(string name, bool disposeData)
	{

		if (_dragonBonesDataMap.ContainsKey(name))
		{
			if (disposeData)
			{
			    _dragonBonesDataMap[name].dispose();
				//delete iterator.second;
			}
			
			_dragonBonesDataMap.Remove(name);
		}
	}
	
	public ITextureAtlas getTextureAtlas(string name) 
	{
		
		if (_textureAtlasMap.ContainsKey(name))
		{
				return _textureAtlasMap[name];
		}
		else
		{
			return null;
		}
	}
	public void addTextureAtlas(ITextureAtlas textureAtlas, string name)
	{
		//DBASSERT(textureAtlas, "Invalid textureAtlas.");
		
		string key = name.Length<=0 ? textureAtlas.textureAtlasData.name : name;
		
		//DBASSERT(!key.empty(), "Name is empty.");
		
		//DBASSERT(_textureAtlasMap.find(key) == _textureAtlasMap.end(), "Data has been added.");
		
		_textureAtlasMap[key] = textureAtlas;
	}
	
	public void removeTextureAtlas(string name, bool disposeData)
	{
		if (_textureAtlasMap.ContainsKey(name))
		{
			if (disposeData)
			{
				_textureAtlasMap[name].dispose();
				//delete iterator.second;
			}
			
			_textureAtlasMap.Remove(name);
		}
	}
	
	public void dispose(bool disposeData)
	{
		if (disposeData)
		{
			foreach (KeyValuePair<string, DragonBonesData>  obj in _dragonBonesDataMap)
			{
				obj.Value.dispose();
				//delete iterator.second;
			}
			
			foreach (KeyValuePair<string,ITextureAtlas> obj in  _textureAtlasMap)
			{
				obj.Value.dispose();
				//delete iterator.second;
			}
		}
		
		_dragonBonesDataMap.Clear();
		_textureAtlasMap.Clear();
	}
	
	public Armature buildArmature(string armatureName) 
	{
		return buildArmature(armatureName, "", armatureName, "", "");
	}
	
	public Armature buildArmature(string armatureName, string dragonBonesName) 
	{
		return buildArmature(armatureName, "", armatureName, dragonBonesName, dragonBonesName);
	}
	
	public Armature buildArmature(string armatureName, string skinName, string animationName, string dragonBonesName, string textureAtlasName) 
	{
		DragonBonesData dragonBonesData = null;
		ArmatureData armatureData = null;
		ArmatureData animationArmatureData = null;
		SkinData skinData = null;
		SkinData skinDataCopy = null;
		
		if (dragonBonesName.Length>0)
		{
			if (_dragonBonesDataMap.ContainsKey(dragonBonesName))
			{
				dragonBonesData = _dragonBonesDataMap[dragonBonesName];
				armatureData = dragonBonesData.getArmatureData(armatureName);
				_currentDragonBonesDataName = dragonBonesName;
				_currentTextureAtlasName = textureAtlasName.Length<=0 ? _currentDragonBonesDataName : textureAtlasName;
			}
		}
		
		if (armatureData==null)
		{
			AutoSearchType searchType = (dragonBonesName.Length<=0 ? AutoSearchType.AST_ALL : (autoSearchDragonBonesData ? AutoSearchType.AST_AUTO : AutoSearchType.AST_NONE));
			
			if (searchType != AutoSearchType.AST_NONE)
			{
				foreach (KeyValuePair<string, DragonBonesData> obj in _dragonBonesDataMap)
				{
				    dragonBonesData = obj.Value;
					
					if (searchType == AutoSearchType.AST_ALL || dragonBonesData.autoSearch)
					{
						armatureData = dragonBonesData.getArmatureData(armatureName);
						
						if (armatureData!=null)
						{
								_currentDragonBonesDataName = obj.Key;
							_currentTextureAtlasName = _currentDragonBonesDataName;
							break;
						}
					}
				}
			}
		}
		
		if (armatureData==null)
		{
			return null;
		}
		
		if (animationName.Length>0 && animationName != armatureName)
		{
			animationArmatureData = dragonBonesData.getArmatureData(animationName);
			
			if (animationArmatureData==null)
			{
				foreach (KeyValuePair<string, DragonBonesData> iterator in _dragonBonesDataMap)
				{
					dragonBonesData = iterator.Value;
					animationArmatureData = dragonBonesData.getArmatureData(animationName);
					
					if (animationArmatureData!=null)
					{
						break;
					}
				}
			}
			
			if (animationArmatureData!=null)
			{
				skinDataCopy = animationArmatureData.getSkinData("");
			}
		}
		
		skinData = armatureData.getSkinData(skinName);
		Armature armature = generateArmature(armatureData);
		armature.name = armatureName;
		
		if (animationArmatureData!=null)
		{
			armature.getAnimation().setAnimationDataList(animationArmatureData.animationDataList);
		}
		else
		{
			armature.getAnimation().setAnimationDataList(armatureData.animationDataList);
		}
		
		//
		buildBones(armature, armatureData);
		
		//
		if (skinData!=null)
		{
			buildSlots(armature, armatureData, skinData, skinDataCopy);
		}
		
		// update armature pose
		armature.getAnimation().play();
		armature.advanceTime(0);
		armature.getAnimation().stop();
		return armature;
	}
	
	public object getTextureDisplay(string textureName, string textureAtlasName, DisplayData displayData) 
	{
		ITextureAtlas textureAtlas = null;
		TextureData textureData = null;
		
		if (textureAtlasName.Length>0)
		{
			if (_textureAtlasMap.ContainsKey(textureAtlasName))
			{
				textureAtlas = _textureAtlasMap[textureAtlasName];
				textureData = textureAtlas.textureAtlasData.getTextureData(textureName);
			}
		}
		
		if (textureData==null)
		{
			AutoSearchType searchType = (textureAtlasName.Length<=0 ? AutoSearchType.AST_ALL : (autoSearchTexture ? AutoSearchType.AST_AUTO : AutoSearchType.AST_NONE));
			
			if (searchType != AutoSearchType.AST_NONE)
			{
				foreach (KeyValuePair<string, ITextureAtlas> iterator in _textureAtlasMap)
				{
					textureAtlas = iterator.Value;
					
					if (searchType == AutoSearchType.AST_ALL || textureAtlas.textureAtlasData.autoSearch)
					{
						textureData = textureAtlas.textureAtlasData.getTextureData(textureName);
						
						if (textureData!=null)
						{
							break;
						}
					}
				}
			}
		}
		
		if (textureData==null)
		{
			return null;
		}
		
		if (displayData==null)
		{
			
			if (_dragonBonesDataMap.ContainsKey(textureAtlas.textureAtlasData.name))
			{
				DragonBonesData dragonBonesData = _dragonBonesDataMap[textureAtlas.textureAtlasData.name];
				
				for (int i = 0; i < dragonBonesData.armatureDataList.Count;  ++i)
				{
						for (int j = 0; j < dragonBonesData.armatureDataList[i].skinDataList.Count;  ++j)
					{
							for (int k = 0; k < dragonBonesData.armatureDataList[i].skinDataList[j].slotDataList.Count; ++k)
						{
							for (int m = 0; m < dragonBonesData.armatureDataList[i].skinDataList[j].slotDataList[k].displayDataList.Count;  ++m)
							{
								displayData = dragonBonesData.armatureDataList[i].skinDataList[j].slotDataList[k].displayDataList[m];
								
								if (displayData.name != textureName)
								{
									displayData = null;
								}
								else
								{
									break;
								}
							}
							
							if (displayData!=null)
							{
								break;
							}
						}
						
						if (displayData!=null)
						{
							break;
						}
					}
					
					if (displayData!=null)
					{
						break;
					}
				}
			}
		}
		
		return generateDisplay(textureAtlas, textureData, displayData);
	}
	
	public void buildBones(Armature armature, ArmatureData armatureData) 
	{
		for (int i = 0; i < armatureData.boneDataList.Count; ++i)
		{
		    BoneData boneData = armatureData.boneDataList[i];
			Bone bone = new Bone();
			bone.name = boneData.name;
			bone.inheritRotation = boneData.inheritRotation;
			bone.inheritScale = boneData.inheritScale;
			// copy
			bone.origin.Copy( boneData.transform);
           
            if (armatureData.getBoneData(boneData.parent)!=null)
			{
				armature.addBone(bone, boneData.parent);
			}
			else
			{
				armature.addBone(bone);
			}
		}
	}
	
	public void buildSlots(Armature armature, ArmatureData armatureData, SkinData skinData, SkinData skinDataCopy) 
	{
		for (int i = 0; i < skinData.slotDataList.Count;  ++i)
		{
			SlotData slotData = skinData.slotDataList[i];
			Bone bone = armature.getBone(slotData.parent);
			
			if (bone==null)
			{
				continue;
			}
			
			Slot slot = generateSlot(slotData);
			slot.name = slotData.name;
			slot._originZOrder = slotData.zOrder;
			slot._slotData = slotData;
			List<KeyValuePair<object, DragonBones.DisplayType>> displayList = new List<KeyValuePair<object, DragonBones.DisplayType>>();
			object frameDisplay = null;
			
			for (int j = 0; j < slotData.displayDataList.Count; ++j)
			{
				DisplayData displayData = slotData.displayDataList[j];
				
				switch (displayData.type)
				{
				case DragonBones.DisplayType.DT_ARMATURE:
				{
					DisplayData displayDataCopy = null;
					
					if (skinDataCopy!=null)
					{
						 SlotData slotDataCopy = skinDataCopy.getSlotData(slotData.name);
						
						if (slotDataCopy!=null)
						{
							displayDataCopy = slotDataCopy.displayDataList[i];
						}
					}
					string currentDragonBonesDataName = _currentDragonBonesDataName;
					string currentTextureAtlasName = _currentTextureAtlasName;
					Armature childArmature = buildArmature(displayData.name, "", (displayDataCopy!=null) ? displayDataCopy.name : "", currentDragonBonesDataName, currentTextureAtlasName);
						displayList.Add(new KeyValuePair<object, DragonBones.DisplayType>(childArmature, DragonBones.DisplayType.DT_ARMATURE));
					_currentDragonBonesDataName = currentDragonBonesDataName;
					_currentTextureAtlasName = currentTextureAtlasName;
					break;
				}
					
				case DragonBones.DisplayType.DT_IMAGE:
				default:
                            ITextureAtlas textureAtlas = _textureAtlasMap[_currentTextureAtlasName];
                            TextureData textureData = textureAtlas.textureAtlasData.getTextureData(displayData.name);
                            displayList.Add(new KeyValuePair<object, DragonBones.DisplayType>(generateDisplay(textureAtlas, textureData, displayData), DragonBones.DisplayType.DT_IMAGE));
					break;
				}
			}
				
			bone.addChild(slot);
				
			if (displayList.Count>0)
			{
					slot.setDisplayList(displayList, false);
			}

	   }
     }



			
		protected virtual Armature generateArmature( ArmatureData armatureData)
		{
			return null;
		}
		protected virtual Slot generateSlot( SlotData slotData)
		{
			return null;
		}
		protected virtual object generateDisplay( ITextureAtlas textureAtlas,  TextureData textureData,  DisplayData displayData)
		{
			return null;
		}
  }
}
					
					