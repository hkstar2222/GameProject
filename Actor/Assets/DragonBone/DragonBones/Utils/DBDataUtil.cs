// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using Com.Viperstudio.Utils;
using Com.Viperstudio.Geom;

namespace DragonBones
{
	public class DBDataUtil
	{
		private static DBTransform _helpTransform1 = new DBTransform();
		private static DBTransform _helpTransform2 = new DBTransform();
		
		public static void TransformArmatureData(ArmatureData armatureData)
		{
			List<BoneData> boneDataList = armatureData.boneDataList;
			int i = boneDataList.Count;
			BoneData boneData;
			BoneData parentBoneData;
			while(i -- >0)
			{
                
				boneData = boneDataList[i];
				if(boneData.parent!=null)
				{
					parentBoneData = armatureData.getBoneData(boneData.parent);
					if(parentBoneData!=null)
					{
						boneData.transform.Copy(boneData.global);

						//Logger.Log(boneData.name + "  " + boneData.transform.X + "  " + boneData.transform.Y);
						TransformUtil.TransformPointWithParent(boneData.transform, parentBoneData.global);
						//Logger.Log(boneData.name + "  " + boneData.transform.X + "  " + boneData.transform.Y);
					}
				}
			}
		}
		
        /*
		public static void transformArmatureDataAnimations(ArmatureData armatureData)
		{
			List<AnimationData> animationDataList = armatureData.AnimationDataList;
			int i = animationDataList.Count;
			while(i -- >0)
			{
				TransformAnimationData(animationDataList[i], armatureData);
			}
		}
        */
		
		public static void TransformAnimationData(AnimationData animationData, ArmatureData armatureData)
		{
			SkinData skinData = armatureData.getSkinData("");
			List<BoneData> boneDataList = armatureData.boneDataList;
			List<SlotData> slotDataList = skinData.slotDataList;
			int i = boneDataList.Count;
			
			BoneData boneData;
			TransformTimeline timeline;
			SlotData slotData;
			DisplayData displayData;
			TransformTimeline parentTimeline;
			List<Frame> frameList;
			DBTransform originTransform;
			Point originPivot;
			TransformFrame prevFrame;
			uint frameListLength;
			TransformFrame frame;
			
			while(i -- >0)
			{
								
				boneData = boneDataList[i];
				timeline = animationData.getTimeline(boneData.name);
				if(timeline == null)
				{
					continue;
				}
				
				slotData = null;
				foreach(SlotData slotDataObj in slotDataList)
				{
					if(slotDataObj.parent == boneData.name)
					{

						slotData = slotDataObj;
						break;
					}
				}
				
				parentTimeline = boneData.parent!=null?animationData.getTimeline(boneData.parent):null;
				
				frameList = timeline.frameList;
				
				originTransform = null;
				originPivot = null;
				prevFrame = null;
				frameListLength = (uint)frameList.Count;
				for(int j = 0;j < frameListLength;j ++)
				{
					frame = frameList[j] as TransformFrame;
					if(parentTimeline!=null)
					{
						//tweenValues to transform.
						_helpTransform1.Copy(frame.global);
						
						//get transform from parent timeline.
						GetTimelineTransform(parentTimeline, frame.position, _helpTransform2);
						TransformUtil.TransformPointWithParent(_helpTransform1, _helpTransform2);
						
						//transform to tweenValues.
						frame.transform.Copy(_helpTransform1);
					}
					else
					{
						frame.transform.Copy(frame.global);
					}

					frame.transform.X -= boneData.transform.X;
					frame.transform.Y -= boneData.transform.Y;
					frame.transform.SkewX -= boneData.transform.SkewX;
					frame.transform.SkewY -= boneData.transform.SkewY;
					frame.transform.ScaleX -= boneData.transform.ScaleX;
					frame.transform.ScaleY -= boneData.transform.ScaleY;
					
					if(!timeline.transformed)
					{
						if(slotData!=null)
						{
							frame.zOrder -= slotData.zOrder;
						}
					}
					
					if(originTransform == null)
					{
						originTransform = timeline.originTransform;
						originTransform.Copy(frame.transform);
						originTransform.SkewX = TransformUtil.FormatRadian(originTransform.SkewX);
						originTransform.SkewY = TransformUtil.FormatRadian(originTransform.SkewY);
						originPivot = timeline.originPivot;
						originPivot.X = frame.pivot.X;
						originPivot.Y = frame.pivot.Y;
					}
					
					frame.transform.X -= originTransform.X;
					frame.transform.Y -= originTransform.Y;
					frame.transform.SkewX = TransformUtil.FormatRadian(frame.transform.SkewX - originTransform.SkewX);
					frame.transform.SkewY = TransformUtil.FormatRadian(frame.transform.SkewY - originTransform.SkewY);
					frame.transform.ScaleX -= originTransform.ScaleX;
					frame.transform.ScaleY -= originTransform.ScaleY;

					if(!timeline.transformed)
					{
						frame.pivot.Y -= originPivot.X;
						frame.pivot.Y -= originPivot.Y;
					}
					
					if(prevFrame!=null)
					{
						float dLX = frame.transform.SkewX - prevFrame.transform.SkewX;
						
						if(prevFrame.tweenRotate!=0)
						{
							
							if(prevFrame.tweenRotate > 0)
							{
								if(dLX < 0)
								{
									frame.transform.SkewX += (float)Math.PI * 2f;
									frame.transform.SkewY += (float)Math.PI * 2f;
								}
								
								if(prevFrame.tweenRotate > 1)
								{
									frame.transform.SkewX += (float)Math.PI * 2f * ((float)prevFrame.tweenRotate - 1f);
									frame.transform.SkewY += (float)Math.PI * 2f * ((float)prevFrame.tweenRotate - 1f);
								}
							}
							else
							{
								if(dLX > 0)
								{
									frame.transform.SkewX -= (float)Math.PI * 2f;
									frame.transform.SkewY -= (float)Math.PI * 2f;
								}
								
								if(prevFrame.tweenRotate < 1)
								{
									frame.transform.SkewX += (float)Math.PI * 2f * ((float)prevFrame.tweenRotate + 1f);
									frame.transform.SkewY += (float)Math.PI * 2f * ((float)prevFrame.tweenRotate + 1f);
								}
							}
						}
						else
						{
							frame.transform.SkewX = prevFrame.transform.SkewX + TransformUtil.FormatRadian(frame.transform.SkewX - prevFrame.transform.SkewX);
							frame.transform.SkewY = prevFrame.transform.SkewY + TransformUtil.FormatRadian(frame.transform.SkewY - prevFrame.transform.SkewY);
						}
					}
					
					prevFrame = frame;
				}
				timeline.transformed = true;
			}
		}
		
		public static void GetTimelineTransform(TransformTimeline timeline, float position, DBTransform retult)
		{
			List<Frame> frameList = timeline.frameList;
			int i = frameList.Count;
			
			TransformFrame currentFrame;
			float tweenEasing;
			float progress;
			TransformFrame nextFrame;
			while(i -- >0)
			{
				currentFrame = frameList[i] as TransformFrame;
				if(currentFrame.position <= position && currentFrame.position + currentFrame.duration > position)
				{
					tweenEasing = currentFrame.tweenEasing;
					if(i == frameList.Count - 1 || float.IsNaN(tweenEasing) || position == currentFrame.position)
					{
						retult.Copy(currentFrame.global);
					}
					else
					{
						progress = (position - currentFrame.position) / currentFrame.duration;
						if(tweenEasing!=0&&!float.IsNaN(tweenEasing))
						{
							progress = TimelineState.GetEaseValue(progress, tweenEasing);
						}
						
						nextFrame = frameList[i + 1] as TransformFrame;
						
						retult.X = currentFrame.global.X +  (nextFrame.global.X - currentFrame.global.X) * progress;
						retult.Y = currentFrame.global.Y +  (nextFrame.global.Y - currentFrame.global.Y) * progress;
						retult.SkewX = TransformUtil.FormatRadian(currentFrame.global.SkewX +  (nextFrame.global.SkewX - currentFrame.global.SkewX) * progress);
						retult.SkewY = TransformUtil.FormatRadian(currentFrame.global.SkewY +  (nextFrame.global.SkewY - currentFrame.global.SkewY) * progress);
						retult.ScaleX = currentFrame.global.ScaleX +  (nextFrame.global.ScaleX - currentFrame.global.ScaleX) * progress;
						retult.ScaleY = currentFrame.global.ScaleY +  (nextFrame.global.ScaleY - currentFrame.global.ScaleY) * progress;
					}
					break;
				}
			}
		}
		
		public static void AddHideTimeline(AnimationData animationData, ArmatureData armatureData)
		{
			List<BoneData> boneDataList =armatureData.boneDataList;
			int i = boneDataList.Count;
			
			BoneData boneData;
			string boneName;
			while(i -- >0)
			{
				boneData = boneDataList[i];
				boneName = boneData.name;
				if(animationData.getTimeline(boneName)==null)
				{
					animationData.AddTimeline(TransformTimeline.HIDE_TIMELINE, boneName);
				}
			}
		}
	}
}

